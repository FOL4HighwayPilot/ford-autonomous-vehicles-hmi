{"version":3,"sources":["../../../src/utils/worker-utils.js"],"names":["getTransferList","object","recursive","transfers","transfersSet","Set","ArrayBuffer","add","buffer","key","undefined","Array","from","WorkerThread","url","metadata","worker","Worker","isBusy","data","Promise","resolve","reject","onmessage","e","onerror","err","postMessage","terminate","WorkerFarm","workerURL","maxConcurrency","debug","initialMessage","capacity","workers","queue","dropped","i","name","broadcast","forEach","find","count","length","shift","getAvailableWorker","job","message","backlog","process","then","onResult","onError","next","push"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* global Worker */\n\nexport function getTransferList(object, recursive = true, transfers) {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (object instanceof ArrayBuffer) {\n    transfersSet.add(object);\n  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], false, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : null;\n}\n\n/**\n * A worker in the WorkerFarm\n */\nclass WorkerThread {\n  constructor({url, metadata}) {\n    this.worker = new Worker(url);\n    this.isBusy = false;\n    this.metadata = metadata;\n  }\n\n  process(data) {\n    const {worker} = this;\n\n    return new Promise((resolve, reject) => {\n      worker.onmessage = e => {\n        this.isBusy = false;\n        // console.log(e.data._size, `${Date.now() - e.data._sentAt}ms`);\n        resolve(e.data);\n      };\n\n      worker.onerror = err => {\n        this.isBusy = false;\n        reject(err);\n      };\n\n      this.isBusy = true;\n      worker.postMessage(data, getTransferList(data));\n    });\n  }\n\n  terminate() {\n    this.worker.terminate();\n    this.worker = null;\n  }\n}\n\n/**\n * Process multiple data messages with a fleet of workers\n */\nexport class WorkerFarm {\n  /**\n   * @param workerURL {function | string} - worker function\n   * @param maxConcurrency {number} - max count of workers\n   */\n  constructor({\n    workerURL,\n    maxConcurrency = 1,\n    debug = () => {},\n    initialMessage = null,\n    capacity = null\n  }) {\n    this.workerURL = workerURL;\n    this.workers = [];\n    this.queue = [];\n    this.debug = debug;\n    this.capacity = capacity;\n    this.dropped = 0;\n\n    for (let i = 0; i < maxConcurrency; i++) {\n      this.workers[i] = new WorkerThread({\n        url: this.workerURL,\n        metadata: {name: `${i}/${maxConcurrency}`}\n      });\n    }\n\n    if (initialMessage) {\n      this.broadcast(initialMessage);\n    }\n  }\n\n  destroy() {\n    this.workers.forEach(worker => worker.terminate());\n  }\n\n  getAvailableWorker() {\n    return this.workers.find(worker => !worker.isBusy);\n  }\n\n  broadcast(data) {\n    const count = this.workers.length;\n    // queue in reverse order as bias worker searching in getAvailableWorker()\n    for (let i = count - 1; i >= 0; i--) {\n      this.workers[i].worker.postMessage(data, getTransferList(data));\n    }\n  }\n\n  next() {\n    const {queue} = this;\n\n    // Drop the oldest data if we are beyond our capacity\n    while (this.capacity && queue.length > this.capacity) {\n      queue.shift();\n      this.dropped++;\n    }\n\n    // Queue data\n    while (queue.length) {\n      const worker = this.getAvailableWorker();\n      if (!worker) {\n        break;\n      }\n      const job = queue.shift();\n\n      this.debug({\n        message: 'processing',\n        worker: worker.metadata.name,\n        backlog: queue.length,\n        dropped: this.dropped\n      });\n\n      worker\n        .process(job.data)\n        .then(job.onResult)\n        .catch(job.onError)\n        .then(() => {\n          this.debug({\n            message: 'waiting',\n            worker: worker.metadata.name,\n            backlog: queue.length,\n            dropped: this.dropped\n          });\n\n          this.next();\n        });\n    }\n  }\n\n  process(data, onResult, onError) {\n    this.queue.push({data, onResult, onError});\n    this.next();\n  }\n}\n"],"file":"worker-utils.js"}