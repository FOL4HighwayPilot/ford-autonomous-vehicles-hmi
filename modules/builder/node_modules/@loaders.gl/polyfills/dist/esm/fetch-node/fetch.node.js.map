{"version":3,"sources":["../../../src/fetch-node/fetch.node.js"],"names":["fs","http","https","util","toArrayBuffer","decodeDataUri","concatenateReadStream","Headers","DEFAULT_OPTIONS","dataType","isDataURL","url","startsWith","isRequestURL","NodeFetchResponse","options","bodyUsed","_headers","readFile","arrayBuffer","textDecoder","TextDecoder","decode","text","JSON","parse","headers","httpResponse","httpHeaders","getHeaders","name","header","String","contentLength","_getContentLength","Number","isFinite","length","stats","statSync","size","_getHeaders","createReadStream","fetchNode","getReadFileOptions","Object","assign","responseType","encoding","Promise","resolve","reject","URL","request","response","then","queryIndex","lastIndexOf","substr","readFileAsync","promisify","buffer","Buffer"],"mappings":"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","sourcesContent":["/* global URL */\n/* global Buffer */\nimport fs from 'fs'; // `fs` will be empty object in browsers (see package.json \"browser\" field).\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\n\n/* global TextDecoder */\n\nimport {toArrayBuffer} from './utils/to-array-buffer.node';\nimport decodeDataUri from './utils/decode-data-uri.node';\nimport {concatenateReadStream} from './utils/stream-utils.node';\nimport Headers from './headers.node';\n\nconst DEFAULT_OPTIONS = {\n  dataType: 'arraybuffer'\n};\n\n// const isNode = Boolean(fs && fs.readFile);\n\nconst isDataURL = url => url.startsWith('data:');\nconst isRequestURL = url => url.startsWith('http:') || url.startsWith('https:');\n\n// Under Node.js we return a mock \"fetch response object\"\n// so that apps can use the same API as in the browser.\n//\n// Note: This is intended to be a lightweight implementation and will have limitations.\n// Apps that require more complete fech emulation in Node\n// are encouraged to use dedicated fetch polyfill modules.\n\n// See https://developer.mozilla.org/en-US/docs/Web/API/Response\nclass NodeFetchResponse {\n  constructor(url, options) {\n    this.url = url;\n    this.options = options;\n    this.bodyUsed = false;\n    this._headers = null;\n  }\n\n  // Subset of Properties\n\n  // get url()\n  get headers() {\n    this._headers = this._headers || this._getHeaders();\n  }\n\n  // Returns a readable stream to the \"body\" of the response (or file)\n  get body() {\n    const {url, options} = this;\n    this.bodyUsed = true;\n    return createReadStream(url, options);\n  }\n\n  // Subset of Methods\n\n  async arrayBuffer() {\n    this.bodyUsed = true;\n    return readFile(this.url, this.options);\n  }\n\n  async text() {\n    const arrayBuffer = await this.arrayBuffer();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(arrayBuffer);\n  }\n\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n  // PRIVATE\n\n  _getHeaders() {\n    // Under Node.js we return a mock \"fetch response object\"\n    // so that apps can use the same API as in the browser.\n    //\n    // Note: This is intended to be a lightweight implementation and will have limitations.\n    // Apps that require more complete fech emulation in Node\n    // are encouraged to use dedicated fetch polyfill modules.\n\n    const headers = {};\n\n    if (this.httpResponse) {\n      const httpHeaders = this.httpResponse.getHeaders();\n      for (const name in httpHeaders) {\n        const header = headers[name];\n        headers[name] = String(header);\n      }\n    } else {\n      const contentLength = this._getContentLength();\n      if (Number.isFinite(contentLength)) {\n        headers['Content-Length'] = contentLength;\n      }\n    }\n\n    return new Headers(headers);\n  }\n\n  _getContentLength() {\n    if (isRequestURL(this.url)) {\n      // Needs to be read from actual headers\n      return null;\n    } else if (isDataURL(this.url)) {\n      return this.url.length - 'data://'.length;\n    }\n    // File URL\n    // TODO - how to handle non-existing file, this presumably just throws\n    const stats = fs.statSync(this.url);\n    return stats.size;\n  }\n}\n\nexport default function fetchNode(url, options) {\n  return new NodeFetchResponse(url, options);\n}\n\n// HELPERS\n\nfunction getReadFileOptions(options = {}) {\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  options.responseType = options.responseType || options.dataType;\n  if (fs) {\n    // set encoding for fs.readFile\n    options.encoding = options.encoding || (options.dataType === 'text' ? 'utf8' : null);\n  }\n  return options;\n}\n\n// Reads raw file data from:\n// * http/http urls\n// * data urls\n// * File/Blob objects\n// etc?\nasync function readFile(url, options = {}) {\n  options = getReadFileOptions(options);\n\n  if (isDataURL(url)) {\n    return Promise.resolve(decodeDataUri(url));\n  }\n\n  if (isRequestURL(url)) {\n    return new Promise((resolve, reject) => {\n      options = {...new URL(url), ...options};\n      const request = url.startsWith('https:') ? https.request : http.request;\n      request(url, response => concatenateReadStream(response).then(resolve, reject));\n    });\n  }\n\n  // Remove any query parameters when loading from file\n  const queryIndex = url && url.lastIndexOf('?');\n  url = queryIndex >= 0 ? url.substr(0, queryIndex) : url;\n\n  const readFileAsync = util.promisify(fs.readFile);\n  const buffer = await readFileAsync(url, options);\n  return buffer instanceof Buffer ? toArrayBuffer(buffer) : buffer;\n}\n\n// Returns a promise that resolves to a readable stream\nasync function createReadStream(url, options) {\n  // Handle data urls in node, to match `fetch``\n  if (isDataURL(url)) {\n    // TODO - need to return a stream wrapper\n    return decodeDataUri(url);\n  }\n\n  // Handle file streams in node\n  if (!isRequestURL(url)) {\n    return fs.createReadStream(url, options);\n  }\n\n  // HANDLE HTTP/HTTPS REQUESTS IN NODE\n  return new Promise((resolve, reject) => {\n    /* TODO - URL not available in Node.js v8? */\n    options = {...new URL(url), ...options};\n    const request = url.startsWith('https:') ? https.request : http.request;\n    request(url, response => resolve(response));\n  });\n}\n"],"file":"fetch.node.js"}