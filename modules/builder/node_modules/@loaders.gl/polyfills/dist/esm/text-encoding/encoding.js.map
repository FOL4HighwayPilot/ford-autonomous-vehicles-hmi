{"version":3,"sources":["../../../src/text-encoding/encoding.js"],"names":["global","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","labels","name","heading","forEach","category","encoding","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder"],"mappings":"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","sourcesContent":["/* eslint-disable */\n// Copied from https://github.com/inexorabletash/text-encoding/blob/b4e5bc26e26e51f56e3daa9f13138c79f49d3c34/lib/encoding.js\n//\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n// FORK: indices add half a megabyte to bundle. Ignore, since we only want the built-in UTF8...\n// global['encoding-indexes'] = require('./encoding-indexes.js')['encoding-indexes'];\nglobal['encoding-indexes'] = {};\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {!Array.<*>} array The array to check.\n * @param {*} item The item to look for in the array.\n * @return {boolean} True if the item appears in the array.\n */\nfunction includes(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nvar floor = Math.floor;\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xd800 || c > 0xdfff) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00  c  0xDFFF\n    else if (0xdc00 <= c && c <= 0xdfff) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xfffd);\n    }\n\n    // 0xD800  c  0xDBFF\n    else if (0xd800 <= c && c <= 0xdbff) {\n      // 1. If i = n1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xfffd);\n      }\n      // 2. Otherwise, i < n1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1);\n\n        // 2. If 0xDC00  d  0xDFFF, then:\n        if (0xdc00 <= d && d <= 0xdfff) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3ff;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3ff;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else {\n          u.push(0xfffd);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nfunction isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7f;\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nvar isASCIICodePoint = isASCIIByte;\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n * the stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n  // Reversed as push/pop is more efficient than shift/unshift.\n  this.tokens.reverse();\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function() {\n    if (!this.tokens.length) return end_of_stream;\n    return this.tokens.pop();\n  },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ (token);\n      while (tokens.length) this.tokens.push(tokens.pop());\n    } else {\n      this.tokens.push(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/ (token);\n      while (tokens.length) this.tokens.unshift(tokens.shift());\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n};\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nfunction encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.');\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n// 5.2 Names and labels\n\n// TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n// https://github.com/google/closure-compiler/issues/247\n\n/**\n * @param {string} label The encoding label.\n * @return {?{name:string,labels:Array.<string>}}\n */\nfunction getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label)\n    .trim()\n    .toLowerCase();\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n  return null;\n}\n\n/**\n * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n * @const\n * @type {!Array.<{\n *          heading: string,\n *          encodings: Array.<{name:string,labels:Array.<string>}>\n *        }>}\n */\nvar encodings = [\n  {\n    encodings: [\n      {\n        labels: ['unicode-1-1-utf-8', 'utf-8', 'utf8'],\n        name: 'UTF-8'\n      }\n    ],\n    heading: 'The Encoding'\n  },\n  {\n    encodings: [\n      {\n        labels: ['866', 'cp866', 'csibm866', 'ibm866'],\n        name: 'IBM866'\n      },\n      {\n        labels: [\n          'csisolatin2',\n          'iso-8859-2',\n          'iso-ir-101',\n          'iso8859-2',\n          'iso88592',\n          'iso_8859-2',\n          'iso_8859-2:1987',\n          'l2',\n          'latin2'\n        ],\n        name: 'ISO-8859-2'\n      },\n      {\n        labels: [\n          'csisolatin3',\n          'iso-8859-3',\n          'iso-ir-109',\n          'iso8859-3',\n          'iso88593',\n          'iso_8859-3',\n          'iso_8859-3:1988',\n          'l3',\n          'latin3'\n        ],\n        name: 'ISO-8859-3'\n      },\n      {\n        labels: [\n          'csisolatin4',\n          'iso-8859-4',\n          'iso-ir-110',\n          'iso8859-4',\n          'iso88594',\n          'iso_8859-4',\n          'iso_8859-4:1988',\n          'l4',\n          'latin4'\n        ],\n        name: 'ISO-8859-4'\n      },\n      {\n        labels: [\n          'csisolatincyrillic',\n          'cyrillic',\n          'iso-8859-5',\n          'iso-ir-144',\n          'iso8859-5',\n          'iso88595',\n          'iso_8859-5',\n          'iso_8859-5:1988'\n        ],\n        name: 'ISO-8859-5'\n      },\n      {\n        labels: [\n          'arabic',\n          'asmo-708',\n          'csiso88596e',\n          'csiso88596i',\n          'csisolatinarabic',\n          'ecma-114',\n          'iso-8859-6',\n          'iso-8859-6-e',\n          'iso-8859-6-i',\n          'iso-ir-127',\n          'iso8859-6',\n          'iso88596',\n          'iso_8859-6',\n          'iso_8859-6:1987'\n        ],\n        name: 'ISO-8859-6'\n      },\n      {\n        labels: [\n          'csisolatingreek',\n          'ecma-118',\n          'elot_928',\n          'greek',\n          'greek8',\n          'iso-8859-7',\n          'iso-ir-126',\n          'iso8859-7',\n          'iso88597',\n          'iso_8859-7',\n          'iso_8859-7:1987',\n          'sun_eu_greek'\n        ],\n        name: 'ISO-8859-7'\n      },\n      {\n        labels: [\n          'csiso88598e',\n          'csisolatinhebrew',\n          'hebrew',\n          'iso-8859-8',\n          'iso-8859-8-e',\n          'iso-ir-138',\n          'iso8859-8',\n          'iso88598',\n          'iso_8859-8',\n          'iso_8859-8:1988',\n          'visual'\n        ],\n        name: 'ISO-8859-8'\n      },\n      {\n        labels: ['csiso88598i', 'iso-8859-8-i', 'logical'],\n        name: 'ISO-8859-8-I'\n      },\n      {\n        labels: [\n          'csisolatin6',\n          'iso-8859-10',\n          'iso-ir-157',\n          'iso8859-10',\n          'iso885910',\n          'l6',\n          'latin6'\n        ],\n        name: 'ISO-8859-10'\n      },\n      {\n        labels: ['iso-8859-13', 'iso8859-13', 'iso885913'],\n        name: 'ISO-8859-13'\n      },\n      {\n        labels: ['iso-8859-14', 'iso8859-14', 'iso885914'],\n        name: 'ISO-8859-14'\n      },\n      {\n        labels: ['csisolatin9', 'iso-8859-15', 'iso8859-15', 'iso885915', 'iso_8859-15', 'l9'],\n        name: 'ISO-8859-15'\n      },\n      {\n        labels: ['iso-8859-16'],\n        name: 'ISO-8859-16'\n      },\n      {\n        labels: ['cskoi8r', 'koi', 'koi8', 'koi8-r', 'koi8_r'],\n        name: 'KOI8-R'\n      },\n      {\n        labels: ['koi8-ru', 'koi8-u'],\n        name: 'KOI8-U'\n      },\n      {\n        labels: ['csmacintosh', 'mac', 'macintosh', 'x-mac-roman'],\n        name: 'macintosh'\n      },\n      {\n        labels: ['dos-874', 'iso-8859-11', 'iso8859-11', 'iso885911', 'tis-620', 'windows-874'],\n        name: 'windows-874'\n      },\n      {\n        labels: ['cp1250', 'windows-1250', 'x-cp1250'],\n        name: 'windows-1250'\n      },\n      {\n        labels: ['cp1251', 'windows-1251', 'x-cp1251'],\n        name: 'windows-1251'\n      },\n      {\n        labels: [\n          'ansi_x3.4-1968',\n          'ascii',\n          'cp1252',\n          'cp819',\n          'csisolatin1',\n          'ibm819',\n          'iso-8859-1',\n          'iso-ir-100',\n          'iso8859-1',\n          'iso88591',\n          'iso_8859-1',\n          'iso_8859-1:1987',\n          'l1',\n          'latin1',\n          'us-ascii',\n          'windows-1252',\n          'x-cp1252'\n        ],\n        name: 'windows-1252'\n      },\n      {\n        labels: ['cp1253', 'windows-1253', 'x-cp1253'],\n        name: 'windows-1253'\n      },\n      {\n        labels: [\n          'cp1254',\n          'csisolatin5',\n          'iso-8859-9',\n          'iso-ir-148',\n          'iso8859-9',\n          'iso88599',\n          'iso_8859-9',\n          'iso_8859-9:1989',\n          'l5',\n          'latin5',\n          'windows-1254',\n          'x-cp1254'\n        ],\n        name: 'windows-1254'\n      },\n      {\n        labels: ['cp1255', 'windows-1255', 'x-cp1255'],\n        name: 'windows-1255'\n      },\n      {\n        labels: ['cp1256', 'windows-1256', 'x-cp1256'],\n        name: 'windows-1256'\n      },\n      {\n        labels: ['cp1257', 'windows-1257', 'x-cp1257'],\n        name: 'windows-1257'\n      },\n      {\n        labels: ['cp1258', 'windows-1258', 'x-cp1258'],\n        name: 'windows-1258'\n      },\n      {\n        labels: ['x-mac-cyrillic', 'x-mac-ukrainian'],\n        name: 'x-mac-cyrillic'\n      }\n    ],\n    heading: 'Legacy single-byte encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'chinese',\n          'csgb2312',\n          'csiso58gb231280',\n          'gb2312',\n          'gb_2312',\n          'gb_2312-80',\n          'gbk',\n          'iso-ir-58',\n          'x-gbk'\n        ],\n        name: 'GBK'\n      },\n      {\n        labels: ['gb18030'],\n        name: 'gb18030'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (simplified) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['big5', 'big5-hkscs', 'cn-big5', 'csbig5', 'x-x-big5'],\n        name: 'Big5'\n      }\n    ],\n    heading: 'Legacy multi-byte Chinese (traditional) encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['cseucpkdfmtjapanese', 'euc-jp', 'x-euc-jp'],\n        name: 'EUC-JP'\n      },\n      {\n        labels: ['csiso2022jp', 'iso-2022-jp'],\n        name: 'ISO-2022-JP'\n      },\n      {\n        labels: [\n          'csshiftjis',\n          'ms932',\n          'ms_kanji',\n          'shift-jis',\n          'shift_jis',\n          'sjis',\n          'windows-31j',\n          'x-sjis'\n        ],\n        name: 'Shift_JIS'\n      }\n    ],\n    heading: 'Legacy multi-byte Japanese encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: [\n          'cseuckr',\n          'csksc56011987',\n          'euc-kr',\n          'iso-ir-149',\n          'korean',\n          'ks_c_5601-1987',\n          'ks_c_5601-1989',\n          'ksc5601',\n          'ksc_5601',\n          'windows-949'\n        ],\n        name: 'EUC-KR'\n      }\n    ],\n    heading: 'Legacy multi-byte Korean encodings'\n  },\n  {\n    encodings: [\n      {\n        labels: ['csiso2022kr', 'hz-gb-2312', 'iso-2022-cn', 'iso-2022-cn-ext', 'iso-2022-kr'],\n        name: 'replacement'\n      },\n      {\n        labels: ['utf-16be'],\n        name: 'UTF-16BE'\n      },\n      {\n        labels: ['utf-16', 'utf-16le'],\n        name: 'UTF-16LE'\n      },\n      {\n        labels: ['x-user-defined'],\n        name: 'x-user-defined'\n      }\n    ],\n    heading: 'Legacy miscellaneous encodings'\n  }\n];\n\n// Label to encoding registry.\n/** @type {Object.<string,{name:string,labels:Array.<string>}>} */\nvar label_to_encoding = {};\nencodings.forEach(function(category) {\n  category.encodings.forEach(function(encoding) {\n    encoding.labels.forEach(function(label) {\n      label_to_encoding[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\n/** @type {Object.<string, function({fatal:boolean}): Encoder>} */\nvar encoders = {};\n/** @type {Object.<string, function({fatal:boolean}): Decoder>} */\nvar decoders = {};\n\n//\n// 6. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\nfunction indexCodePointFor(pointer, index) {\n  if (!index) return null;\n  return index[pointer] || null;\n}\n\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {!Array.<?number>} index The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\nfunction indexPointerFor(code_point, index) {\n  var pointer = index.indexOf(code_point);\n  return pointer === -1 ? null : pointer;\n}\n\n/**\n * @param {string} name Name of the index.\n * @return {(!Array.<number>|!Array.<Array.<number>>)}\n *  */\nfunction index(name) {\n  if (!('encoding-indexes' in global)) {\n    throw Error('Indexes missing.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n  return global['encoding-indexes'][name];\n}\n\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\nfunction indexGB18030RangesCodePointFor(pointer) {\n  // 1. If pointer is greater than 39419 and less than 189000, or\n  // pointer is greater than 1237575, return null.\n  if ((pointer > 39419 && pointer < 189000) || pointer > 1237575) return null;\n\n  // 2. If pointer is 7457, return code point U+E7C7.\n  if (pointer === 7457) return 0xe7c7;\n\n  // 3. Let offset be the last pointer in index gb18030 ranges that\n  // is equal to or less than pointer and let code point offset be\n  // its corresponding code point.\n  var offset = 0;\n  var code_point_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[0] <= pointer) {\n      offset = entry[0];\n      code_point_offset = entry[1];\n    } else {\n      break;\n    }\n  }\n\n  // 4. Return a code point whose value is code point offset +\n  // pointer  offset.\n  return code_point_offset + pointer - offset;\n}\n\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\nfunction indexGB18030RangesPointerFor(code_point) {\n  // 1. If code point is U+E7C7, return pointer 7457.\n  if (code_point === 0xe7c7) return 7457;\n\n  // 2. Let offset be the last code point in index gb18030 ranges\n  // that is equal to or less than code point and let pointer offset\n  // be its corresponding pointer.\n  var offset = 0;\n  var pointer_offset = 0;\n  var idx = index('gb18030-ranges');\n  var i;\n  for (i = 0; i < idx.length; ++i) {\n    /** @type {!Array.<number>} */\n    var entry = idx[i];\n    if (entry[1] <= code_point) {\n      offset = entry[1];\n      pointer_offset = entry[0];\n    } else {\n      break;\n    }\n  }\n\n  // 3. Return a pointer whose value is pointer offset + code point\n  //  offset.\n  return pointer_offset + code_point - offset;\n}\n\n/**\n * @param {number} code_point The |code_point| to search for in the Shift_JIS\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the Shift_JIS index.\n */\nfunction indexShiftJISPointerFor(code_point) {\n  // 1. Let index be index jis0208 excluding all entries whose\n  // pointer is in the range 8272 to 8835, inclusive.\n  shift_jis_index =\n    shift_jis_index ||\n    index('jis0208').map(function(code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n  var index_ = shift_jis_index;\n\n  // 2. Return the index pointer for code point in index.\n  return index_.indexOf(code_point);\n}\nvar shift_jis_index;\n\n/**\n * @param {number} code_point The |code_point| to search for in the big5\n *     index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the big5 index.\n */\nfunction indexBig5PointerFor(code_point) {\n  // 1. Let index be index Big5 excluding all entries whose pointer\n  big5_index_no_hkscs =\n    big5_index_no_hkscs ||\n    index('big5').map(function(code_point, pointer) {\n      return pointer < (0xa1 - 0x81) * 157 ? null : code_point;\n    });\n  var index_ = big5_index_no_hkscs;\n\n  // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n  // U+5345, return the last pointer corresponding to code point in\n  // index.\n  if (\n    code_point === 0x2550 ||\n    code_point === 0x255e ||\n    code_point === 0x2561 ||\n    code_point === 0x256a ||\n    code_point === 0x5341 ||\n    code_point === 0x5345\n  ) {\n    return index_.lastIndexOf(code_point);\n  }\n\n  // 3. Return the index pointer for code point in index.\n  return indexPointerFor(code_point, index_);\n}\nvar big5_index_no_hkscs;\n\n//\n// 8. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 8.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextDecoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n  options = ToDictionary(options);\n\n  // A TextDecoder object has an associated encoding, decoder,\n  // stream, ignore BOM flag (initially unset), BOM seen flag\n  // (initially unset), error mode (initially replacement), and do\n  // not flush flag (initially unset).\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._ignoreBOM = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {string} */\n  this._error_mode = 'replacement';\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n\n  // 1. Let encoding be the result of getting an encoding from\n  // label.\n  var encoding = getEncoding(label);\n\n  // 2. If encoding is failure or replacement, throw a RangeError.\n  if (encoding === null || encoding.name === 'replacement')\n    throw RangeError('Unknown encoding: ' + label);\n  if (!decoders[encoding.name]) {\n    throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n  }\n\n  // 3. Let dec be a new TextDecoder object.\n  var dec = this;\n\n  // 4. Set dec's encoding to encoding.\n  dec._encoding = encoding;\n\n  // 5. If options's fatal member is true, set dec's error mode to\n  // fatal.\n  if (Boolean(options['fatal'])) dec._error_mode = 'fatal';\n\n  // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n  // flag.\n  if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) {\n    this.encoding = dec._encoding.name.toLowerCase();\n    this.fatal = dec._error_mode === 'fatal';\n    this.ignoreBOM = dec._ignoreBOM;\n  }\n\n  // 7. Return dec.\n  return dec;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextDecoder.prototype, 'encoding', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n\n  // The fatal attribute's getter must return true if error mode\n  // is fatal, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'fatal', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._error_mode === 'fatal';\n    }\n  });\n\n  // The ignoreBOM attribute's getter must return true if ignore\n  // BOM flag is set, and false otherwise.\n  Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n    /** @this {TextDecoder} */\n    get: function() {\n      return this._ignoreBOM;\n    }\n  });\n}\n\n/**\n * @param {BufferSource=} input The buffer of bytes to decode.\n * @param {Object=} options\n * @return {string} The decoded string.\n */\nTextDecoder.prototype.decode = function decode(input, options) {\n  var bytes;\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    bytes = new Uint8Array(input);\n  } else if (\n    typeof input === 'object' &&\n    'buffer' in input &&\n    input.buffer instanceof ArrayBuffer\n  ) {\n    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  } else {\n    bytes = new Uint8Array(0);\n  }\n\n  options = ToDictionary(options);\n\n  // 1. If the do not flush flag is unset, set decoder to a new\n  // encoding's decoder, set stream to a new stream, and unset the\n  // BOM seen flag.\n  if (!this._do_not_flush) {\n    this._decoder = decoders[this._encoding.name]({\n      fatal: this._error_mode === 'fatal'\n    });\n    this._BOMseen = false;\n  }\n\n  // 2. If options's stream is true, set the do not flush flag, and\n  // unset the do not flush flag otherwise.\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 3. If input is given, push a copy of input to stream.\n  // TODO: Align with spec algorithm - maintain stream on instance.\n  var input_stream = new Stream(bytes);\n\n  // 4. Let output be a new stream.\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n\n  // 5. While true:\n  while (true) {\n    // 1. Let token be the result of reading from stream.\n    var token = input_stream.read();\n\n    // 2. If token is end-of-stream and the do not flush flag is\n    // set, return output, serialized.\n    // TODO: Align with spec algorithm.\n    if (token === end_of_stream) break;\n\n    // 3. Otherwise, run these subsubsteps:\n\n    // 1. Let result be the result of processing token for decoder,\n    // stream, output, and error mode.\n    result = this._decoder.handler(input_stream, token);\n\n    // 2. If result is finished, return output, serialized.\n    if (result === finished) break;\n\n    if (result !== null) {\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    }\n\n    // 3. Otherwise, if result is error, throw a TypeError.\n    // (Thrown in handler)\n\n    // 4. Otherwise, do nothing.\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    do {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished) break;\n      if (result === null) continue;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    } while (!input_stream.endOfStream());\n    this._decoder = null;\n  }\n\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   * @return {string}\n   * @this {TextDecoder}\n   */\n  function serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (\n      includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n      !this._ignoreBOM &&\n      !this._BOMseen\n    ) {\n      if (stream.length > 0 && stream[0] === 0xfeff) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true;\n        stream.shift();\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true;\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream);\n  }\n\n  return serializeStream.call(this, output);\n};\n\n// 8.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} label The label of the encoding. NONSTANDARD.\n * @param {Object=} options NONSTANDARD.\n */\nfunction TextEncoder(label, options) {\n  // Web IDL conventions\n  if (!(this instanceof TextEncoder))\n    throw TypeError(\"Called as a function. Did you forget 'new'?\");\n  options = ToDictionary(options);\n\n  // A TextEncoder object has an associated encoding and encoder.\n\n  /** @private */\n  this._encoding = null;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n\n  // Non-standard\n  /** @private @type {boolean} */\n  this._do_not_flush = false;\n  /** @private @type {string} */\n  this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n  // 1. Let enc be a new TextEncoder object.\n  var enc = this;\n\n  // 2. Set enc's encoding to UTF-8's encoder.\n  if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n    // NONSTANDARD behavior.\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    var encoding = getEncoding(label);\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!encoders[encoding.name]) {\n      throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n    enc._encoding = encoding;\n  } else {\n    // Standard behavior.\n    enc._encoding = getEncoding('utf-8');\n\n    if (label !== undefined && 'console' in global) {\n      console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n    }\n  }\n\n  // For pre-ES5 runtimes:\n  if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();\n\n  // 3. Return enc.\n  return enc;\n}\n\nif (Object.defineProperty) {\n  // The encoding attribute's getter must return encoding's name.\n  Object.defineProperty(TextEncoder.prototype, 'encoding', {\n    /** @this {TextEncoder} */\n    get: function() {\n      return this._encoding.name.toLowerCase();\n    }\n  });\n}\n\n/**\n * @param {string=} opt_string The string to encode.\n * @param {Object=} options\n * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n */\nTextEncoder.prototype.encode = function encode(opt_string, options) {\n  opt_string = opt_string === undefined ? '' : String(opt_string);\n  options = ToDictionary(options);\n\n  // NOTE: This option is nonstandard. None of the encodings\n  // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n  // the input is a USVString so streaming is not necessary.\n  if (!this._do_not_flush)\n    this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n  this._do_not_flush = Boolean(options['stream']);\n\n  // 1. Convert input to a stream.\n  var input = new Stream(stringToCodePoints(opt_string));\n\n  // 2. Let output be a new stream\n  var output = [];\n\n  /** @type {?(number|!Array.<number>)} */\n  var result;\n  // 3. While true, run these substeps:\n  while (true) {\n    // 1. Let token be the result of reading from input.\n    var token = input.read();\n    if (token === end_of_stream) break;\n    // 2. Let result be the result of processing token for encoder,\n    // input, output.\n    result = this._encoder.handler(input, token);\n    if (result === finished) break;\n    if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n    else output.push(result);\n  }\n  // TODO: Align with spec algorithm.\n  if (!this._do_not_flush) {\n    while (true) {\n      result = this._encoder.handler(input, input.read());\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/ (result));\n      else output.push(result);\n    }\n    this._encoder = null;\n  }\n  // 3. If result is finished, convert output into a byte sequence,\n  // and then return a Uint8Array object wrapping an ArrayBuffer\n  // containing output.\n  return new Uint8Array(output);\n};\n\n//\n// 9. The encoding\n//\n\n// 9.1 utf-8\n\n// 9.1.1 utf-8 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n    /** @type {number} */ utf8_bytes_seen = 0,\n    /** @type {number} */ utf8_bytes_needed = 0,\n    /** @type {number} */ utf8_lower_boundary = 0x80,\n    /** @type {number} */ utf8_upper_boundary = 0xbf;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        utf8_bytes_needed = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        utf8_code_point = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) utf8_lower_boundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) utf8_upper_boundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        utf8_bytes_needed = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        utf8_code_point = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) utf8_upper_boundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        utf8_bytes_needed = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        utf8_code_point = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    utf8_code_point = (utf8_code_point << 6) | (bite & 0x3f);\n\n    // 7. Increase utf-8 bytes seen by one.\n    utf8_bytes_seen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n    // 9. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 9.1.2 utf-8 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF, inclusive:\n    if (inRange(code_point, 0x0080, 0x07ff)) {\n      // 1 and 0xC0\n      count = 1;\n      offset = 0xc0;\n    }\n    // U+0800 to U+FFFF, inclusive:\n    else if (inRange(code_point, 0x0800, 0xffff)) {\n      // 2 and 0xE0\n      count = 2;\n      offset = 0xe0;\n    }\n    // U+10000 to U+10FFFF, inclusive:\n    else if (inRange(code_point, 0x10000, 0x10ffff)) {\n      // 3 and 0xF0\n      count = 3;\n      offset = 0xf0;\n    }\n\n    // 4. Let bytes be a byte sequence whose first byte is (code\n    // point >> (6  count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n      // 1. Set temp to code point >> (6  (count  1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3f));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['UTF-8'] = function(options) {\n  return new UTF8Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-8'] = function(options) {\n  return new UTF8Decoder(options);\n};\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {!Array.<number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteDecoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Let code point be the index code point for byte  0x80 in\n    // index single-byte.\n    var code_point = index[bite - 0x80];\n\n    // 4. If code point is null, return error.\n    if (code_point === null) return decoderError(fatal);\n\n    // 5. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n// 10.2 single-byte encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {!Array.<?number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\nfunction SingleByteEncoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    var pointer = indexPointerFor(code_point, index);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) encoderError(code_point);\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80;\n  };\n}\n\n(function() {\n  if (!('encoding-indexes' in global)) return;\n  encodings.forEach(function(category) {\n    if (category.heading !== 'Legacy single-byte encodings') return;\n    category.encodings.forEach(function(encoding) {\n      var name = encoding.name;\n      var idx = index(name.toLowerCase());\n      /** @param {{fatal: boolean}} options */\n      decoders[name] = function(options) {\n        return new SingleByteDecoder(idx, options);\n      };\n      /** @param {{fatal: boolean}} options */\n      encoders[name] = function(options) {\n        return new SingleByteEncoder(idx, options);\n      };\n    });\n  });\n})();\n\n//\n// 11. Legacy multi-byte Chinese (simplified) encodings\n//\n\n// 11.1 gbk\n\n// 11.1.1 gbk decoder\n// gbk's decoder is gb18030's decoder.\n/** @param {{fatal: boolean}} options */\ndecoders['GBK'] = function(options) {\n  return new GB18030Decoder(options);\n};\n\n// 11.1.2 gbk encoder\n// gbk's encoder is gb18030's encoder with its gbk flag set.\n/** @param {{fatal: boolean}} options */\nencoders['GBK'] = function(options) {\n  return new GB18030Encoder(options, true);\n};\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction GB18030Decoder(options) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gb18030 first, gb18030\n  // second, and gb18030 third (all initially 0x00).\n  var /** @type {number} */ gb18030_first = 0x00,\n    /** @type {number} */ gb18030_second = 0x00,\n    /** @type {number} */ gb18030_third = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (\n      bite === end_of_stream &&\n      gb18030_first === 0x00 &&\n      gb18030_second === 0x00 &&\n      gb18030_third === 0x00\n    ) {\n      return finished;\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (\n      bite === end_of_stream &&\n      (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)\n    ) {\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n      decoderError(fatal);\n    }\n    var code_point;\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null;\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first  0x81)  10 + gb18030 second  0x30) \n      // 126 + gb18030 third  0x81)  10 + byte  0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor(\n          (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) *\n            10 +\n            bite -\n            0x30\n        );\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [gb18030_second, gb18030_third, bite];\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      gb18030_third = 0x00;\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer);\n        return decoderError(fatal);\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xfe)) {\n        gb18030_third = bite;\n        return null;\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([gb18030_second, bite]);\n      gb18030_first = 0x00;\n      gb18030_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        gb18030_second = bite;\n        return null;\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = gb18030_first;\n      var pointer = null;\n      gb18030_first = 0x00;\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead  0x81)  190 +\n      // (byte  offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfe))\n        pointer = (lead - 0x81) * 190 + (bite - offset);\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80) return 0x20ac;\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      gb18030_first = bite;\n      return null;\n    }\n\n    // 9. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n * @param {boolean=} gbk_flag\n */\nfunction GB18030Encoder(options, gbk_flag) {\n  var fatal = options.fatal;\n  // gb18030's decoder has an associated gbk flag (initially unset).\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xe5e5) return encoderError(code_point);\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (gbk_flag && code_point === 0x20ac) return 0x80;\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'));\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n      // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190;\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3f ? 0x40 : 0x41;\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (gbk_flag) return encoderError(code_point);\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point);\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10);\n\n    // 10. Set pointer to pointer  byte1  10  126  10.\n    pointer = pointer - byte1 * 10 * 126 * 10;\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126);\n\n    // 12. Set pointer to pointer  byte2  10  126.\n    pointer = pointer - byte2 * 10 * 126;\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10);\n\n    // 14. Let byte4 be pointer  byte3  10.\n    var byte4 = pointer - byte3 * 10;\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['gb18030'] = function(options) {\n  return new GB18030Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['gb18030'] = function(options) {\n  return new GB18030Decoder(options);\n};\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Decoder(options) {\n  var fatal = options.fatal;\n  // Big5's decoder has an associated Big5 lead (initially 0x00).\n  var /** @type {number} */ Big5_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n    // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && Big5_lead !== 0x00) {\n      Big5_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && Big5_lead === 0x00) return finished;\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (Big5_lead !== 0x00) {\n      var lead = Big5_lead;\n      var pointer = null;\n      Big5_lead = 0x00;\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x62;\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead  0x81)  157 +\n      // (byte  offset).\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0xa1, 0xfe))\n        pointer = (lead - 0x81) * 157 + (bite - offset);\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n        case 1133:\n          return [0x00ca, 0x0304];\n        case 1135:\n          return [0x00ca, 0x030c];\n        case 1164:\n          return [0x00ea, 0x0304];\n        case 1166:\n          return [0x00ea, 0x030c];\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 6. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 7. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      Big5_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 12.1.2 Big5 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction Big5Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index Big5 pointer for code point.\n    var pointer = indexBig5PointerFor(code_point);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 157) + 0x81.\n    var lead = floor(pointer / 157) + 0x81;\n\n    // 6. If lead is less than 0xA1, return error with code point.\n    if (lead < 0xa1) return encoderError(code_point);\n\n    // 7. Let trail be pointer % 157.\n    var trail = pointer % 157;\n\n    // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x62;\n\n    // Return two bytes whose values are lead and trail + offset.\n    return [lead, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Big5'] = function(options) {\n  return new Big5Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Big5'] = function(options) {\n  return new Big5Decoder(options);\n};\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-jp's decoder has an associated euc-jp jis0212 flag\n  // (initially unset) and euc-jp lead (initially 0x00).\n  var /** @type {boolean} */ eucjp_jis0212_flag = false,\n    /** @type {number} */ eucjp_lead = 0x00;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n    // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && eucjp_lead !== 0x00) {\n      eucjp_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && eucjp_lead === 0x00) return finished;\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61  0xA1 + byte.\n    if (eucjp_lead === 0x8e && inRange(bite, 0xa1, 0xdf)) {\n      eucjp_lead = 0x00;\n      return 0xff61 - 0xa1 + bite;\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (eucjp_lead === 0x8f && inRange(bite, 0xa1, 0xfe)) {\n      eucjp_jis0212_flag = true;\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (eucjp_lead !== 0x00) {\n      var lead = eucjp_lead;\n      eucjp_lead = 0x00;\n\n      // 1. Let code point be null.\n      var code_point = null;\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      //  0xA1)  94 + byte  0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xa1, 0xfe) && inRange(bite, 0xa1, 0xfe)) {\n        code_point = indexCodePointFor(\n          (lead - 0xa1) * 94 + (bite - 0xa1),\n          index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212')\n        );\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      eucjp_jis0212_flag = false;\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xa1, 0xfe)) stream.prepend(bite);\n\n      // 5. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8e || bite === 0x8f || inRange(bite, 0xa1, 0xfe)) {\n      eucjp_lead = bite;\n      return null;\n    }\n\n    // 8. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCJPEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point \n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return [0x8e, code_point - 0xff61 + 0xa1];\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    var lead = floor(pointer / 94) + 0xa1;\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    var trail = (pointer % 94) + 0xa1;\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-JP'] = function(options) {\n  return new EUCJPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-JP'] = function(options) {\n  return new EUCJPDecoder(options);\n};\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPDecoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    Katakana: 2,\n    LeadByte: 3,\n    TrailByte: 4,\n    EscapeStart: 5,\n    Escape: 6\n  };\n  // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n  // state (initially ASCII), iso-2022-jp decoder output state\n  // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n  // iso-2022-jp output flag (initially unset).\n  var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n    /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n    /** @type {number} */ iso2022jp_lead = 0x00,\n    /** @type {boolean} */ iso2022jp_output_flag = false;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // switching on iso-2022-jp decoder state:\n    switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7f) && bite !== 0x0e && bite !== 0x0f && bite !== 0x1b) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5c) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00a5;\n        }\n\n        // 0x7E\n        if (bite === 0x7e) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203e;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (\n          inRange(bite, 0x00, 0x7f) &&\n          bite !== 0x0e &&\n          bite !== 0x0f &&\n          bite !== 0x1b &&\n          bite !== 0x5c &&\n          bite !== 0x7e\n        ) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5f)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61  0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xff61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1b) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7e)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead  0x21)  94 + byte  0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null) return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42) state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4a) state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49) state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n    }\n  };\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ISO2022JPEncoder(options) {\n  var fatal = options.fatal;\n  // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n  // state which is one of ASCII, Roman, and jis0208 (initially\n  // ASCII).\n  /** @enum */\n  var states = {\n    ASCII: 0,\n    Roman: 1,\n    jis0208: 2\n  };\n  var /** @type {number} */ iso2022jp_state = states.ASCII;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream and iso-2022-jp encoder\n    // state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if (\n      (iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) &&\n      (code_point === 0x000e || code_point === 0x000f || code_point === 0x001b)\n    ) {\n      return encoderError(0xfffd);\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (\n      iso2022jp_state === states.Roman &&\n      ((isASCIICodePoint(code_point) && code_point !== 0x005c && code_point !== 0x007e) ||\n        (code_point == 0x00a5 || code_point == 0x203e))\n    ) {\n      // 1. If code point is an ASCII code point, return a byte\n      // whose value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00a5) return 0x5c;\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203e) return 0x7e;\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.ASCII;\n      return [0x1b, 0x28, 0x42];\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00a5 || code_point === 0x203e) && iso2022jp_state !== states.Roman) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.Roman;\n      return [0x1b, 0x28, 0x4a];\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    var pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (iso2022jp_state !== states.jis0208) {\n      stream.prepend(code_point);\n      iso2022jp_state = states.jis0208;\n      return [0x1b, 0x24, 0x42];\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    var lead = floor(pointer / 94) + 0x21;\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    var trail = (pointer % 94) + 0x21;\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['ISO-2022-JP'] = function(options) {\n  return new ISO2022JPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['ISO-2022-JP'] = function(options) {\n  return new ISO2022JPDecoder(options);\n};\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISDecoder(options) {\n  var fatal = options.fatal;\n  // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n  // 0x00).\n  var /** @type {number} */ Shift_JIS_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n    // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n      Shift_JIS_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (Shift_JIS_lead !== 0x00) {\n      var lead = Shift_JIS_lead;\n      var pointer = null;\n      Shift_JIS_lead = 0x00;\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = bite < 0x7f ? 0x40 : 0x41;\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0xa0 ? 0x81 : 0xc1;\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead  lead offset) \n      // 188 + byte  offset.\n      if (inRange(bite, 0x40, 0x7e) || inRange(bite, 0x80, 0xfc))\n        pointer = (lead - lead_offset) * 188 + bite - offset;\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000  8836 + pointer.\n      if (inRange(pointer, 8836, 10715)) return 0xe000 - 8836 + pointer;\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61  0xA1 + byte.\n    if (inRange(bite, 0xa1, 0xdf)) return 0xff61 - 0xa1 + bite;\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9f) || inRange(bite, 0xe0, 0xfc)) {\n      Shift_JIS_lead = bite;\n      return null;\n    }\n\n    // 7. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction ShiftJISEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00a5) return 0x5c;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203e) return 0x7e;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point  0xFF61 + 0xA1.\n    if (inRange(code_point, 0xff61, 0xff9f)) return code_point - 0xff61 + 0xa1;\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xff0d;\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point);\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188);\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = lead < 0x1f ? 0x81 : 0xc1;\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188;\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = trail < 0x3f ? 0x40 : 0x41;\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['Shift_JIS'] = function(options) {\n  return new ShiftJISEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['Shift_JIS'] = function(options) {\n  return new ShiftJISDecoder(options);\n};\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKRDecoder(options) {\n  var fatal = options.fatal;\n\n  // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n  var /** @type {number} */ euckr_lead = 0x00;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && euckr_lead !== 0) {\n      euckr_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && euckr_lead === 0) return finished;\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (euckr_lead !== 0x00) {\n      var lead = euckr_lead;\n      var pointer = null;\n      euckr_lead = 0x00;\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead  0x81)  190 + (byte  0x41).\n      if (inRange(bite, 0x41, 0xfe)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xfe)) {\n      euckr_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(fatal);\n  };\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction EUCKREncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    var lead = floor(pointer / 190) + 0x81;\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    var trail = (pointer % 190) + 0x41;\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['EUC-KR'] = function(options) {\n  return new EUCKREncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['EUC-KR'] = function(options) {\n  return new EUCKRDecoder(options);\n};\n\n//\n// 15. Legacy miscellaneous encodings\n//\n\n// 15.1 replacement\n\n// Not needed - API throws RangeError\n\n// 15.2 Common infrastructure for utf-16be and utf-16le\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n * @return {!Array.<number>} bytes\n */\nfunction convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  var byte1 = code_unit >> 8;\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  var byte2 = code_unit & 0x00ff;\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be) return [byte1, byte2];\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1];\n}\n\n// 15.2.1 shared utf-16 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Decoder(utf16_be, options) {\n  var fatal = options.fatal;\n  var /** @type {?number} */ utf16_lead_byte = null,\n    /** @type {?number} */ utf16_lead_surrogate = null;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and either utf-16 lead byte or\n    // utf-16 lead surrogate is not null, set utf-16 lead byte and\n    // utf-16 lead surrogate to null, and return error.\n    if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n    // lead surrogate are null, return finished.\n    if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n      return finished;\n    }\n\n    // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n    // and return continue.\n    if (utf16_lead_byte === null) {\n      utf16_lead_byte = bite;\n      return null;\n    }\n\n    // 4. Let code unit be the result of:\n    var code_unit;\n    if (utf16_be) {\n      // utf-16be decoder flag is set\n      //   (utf-16 lead byte << 8) + byte.\n      code_unit = (utf16_lead_byte << 8) + bite;\n    } else {\n      // utf-16be decoder flag is unset\n      //   (byte << 8) + utf-16 lead byte.\n      code_unit = (bite << 8) + utf16_lead_byte;\n    }\n    // Then set utf-16 lead byte to null.\n    utf16_lead_byte = null;\n\n    // 5. If utf-16 lead surrogate is not null, let lead surrogate\n    // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n    // and then run these substeps:\n    if (utf16_lead_surrogate !== null) {\n      var lead_surrogate = utf16_lead_surrogate;\n      utf16_lead_surrogate = null;\n\n      // 1. If code unit is in the range U+DC00 to U+DFFF,\n      // inclusive, return a code point whose value is 0x10000 +\n      // ((lead surrogate  0xD800) << 10) + (code unit  0xDC00).\n      if (inRange(code_unit, 0xdc00, 0xdfff)) {\n        return 0x10000 + (lead_surrogate - 0xd800) * 0x400 + (code_unit - 0xdc00);\n      }\n\n      // 2. Prepend the sequence resulting of converting code unit\n      // to bytes using utf-16be decoder flag to stream and return\n      // error.\n      stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n      return decoderError(fatal);\n    }\n\n    // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n    // set utf-16 lead surrogate to code unit and return continue.\n    if (inRange(code_unit, 0xd800, 0xdbff)) {\n      utf16_lead_surrogate = code_unit;\n      return null;\n    }\n\n    // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n    // return error.\n    if (inRange(code_unit, 0xdc00, 0xdfff)) return decoderError(fatal);\n\n    // 8. Return code point code unit.\n    return code_unit;\n  };\n}\n\n// 15.2.2 shared utf-16 encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\nfunction UTF16Encoder(utf16_be, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n    // return the sequence resulting of converting code point to\n    // bytes using utf-16be encoder flag.\n    if (inRange(code_point, 0x0000, 0xffff)) return convertCodeUnitToBytes(code_point, utf16_be);\n\n    // 3. Let lead be ((code point  0x10000) >> 10) + 0xD800,\n    // converted to bytes using utf-16be encoder flag.\n    var lead = convertCodeUnitToBytes(((code_point - 0x10000) >> 10) + 0xd800, utf16_be);\n\n    // 4. Let trail be ((code point  0x10000) & 0x3FF) + 0xDC00,\n    // converted to bytes using utf-16be encoder flag.\n    var trail = convertCodeUnitToBytes(((code_point - 0x10000) & 0x3ff) + 0xdc00, utf16_be);\n\n    // 5. Return a byte sequence of lead followed by trail.\n    return lead.concat(trail);\n  };\n}\n\n// 15.3 utf-16be\n// 15.3.1 utf-16be decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16BE'] = function(options) {\n  return new UTF16Encoder(true, options);\n};\n// 15.3.2 utf-16be encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16BE'] = function(options) {\n  return new UTF16Decoder(true, options);\n};\n\n// 15.4 utf-16le\n// 15.4.1 utf-16le decoder\n/** @param {{fatal: boolean}} options */\nencoders['UTF-16LE'] = function(options) {\n  return new UTF16Encoder(false, options);\n};\n// 15.4.2 utf-16le encoder\n/** @param {{fatal: boolean}} options */\ndecoders['UTF-16LE'] = function(options) {\n  return new UTF16Decoder(false, options);\n};\n\n// 15.5 x-user-defined\n\n// 15.5.1 x-user-defined decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedDecoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Return a code point whose value is 0xF780 + byte  0x80.\n    return 0xf780 + bite - 0x80;\n  };\n}\n\n// 15.5.2 x-user-defined encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction XUserDefinedEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1.If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n    // return a byte whose value is code point  0xF780 + 0x80.\n    if (inRange(code_point, 0xf780, 0xf7ff)) return code_point - 0xf780 + 0x80;\n\n    // 4. Return error with code point.\n    return encoderError(code_point);\n  };\n}\n\n/** @param {{fatal: boolean}} options */\nencoders['x-user-defined'] = function(options) {\n  return new XUserDefinedEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\ndecoders['x-user-defined'] = function(options) {\n  return new XUserDefinedDecoder(options);\n};\n\n// FORK\n// if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n// if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\nexport {TextEncoder, TextDecoder};\n"],"file":"encoding.js"}